require "inflector/core_ext"
require "pg"

# This module declare all the methods and macro related to columns in `Clear::Model`
module Clear::Model::HasColumns
  macro included # In Clear::Model
    macro included # In RealModel
      COLUMNS = {} of Nil => Nil
      # Attributes, used when fetch_columns is true
      getter attributes : Hash(String, ::Clear::SQL::Any) = {} of String => ::Clear::SQL::Any

      # Special reinitialization if we detect inheritance (meaning polymorphism)
      macro inherited
        # Reset COLUMNS constants
        COLUMNS = {} of Nil => Nil
        # Table is same than parent table
        self.table = \\{{@type.ancestors.first}}.table
      end
    end
  end

  def set( h : Hash(Symbol, _) )
  end

  def set( h : Hash(String, ::Clear::SQL::Any) )
  end

  # Access to direct SQL attributes given by the request used to build the model.
  # Access is read only and updating the model columns will not apply change to theses columns.
  def [](x) : ::Clear::SQL::Any
    attributes[x]
  end

  # Access to direct SQL attributes given by the request  used to build the model
  # or Nil if not found.
  # Access is read only and updating the model columns will not apply change to theses columns.
  def []?(x) : ::Clear::SQL::Any
    attributes[x]?
  end


  def update_h
    {} of String => ::Clear::SQL::Any
  end

  def to_h
    {} of String => ::Clear::SQL::Any
  end

  # Bind a column to the model.
  #
  # Simple example:
  # ```
  # class MyModel
  #   include Clear::Model
  #
  #   column some_id : Int32, primary: true
  #   column nullable_column : String?
  # end
  # ```
  # options:
  #
  # * `primary : Bool`: Let Clear ORM know which column is the primary key.
  # Currently compound primary key are not compatible with Clear ORM.
  #
  # * `converter : Class | Module`: Use this class to convert the data from the
  # SQL. This class must possess the class methods
  # `to_column(::Clear::SQL::Any) : T` and `to_db(T) : ::Clear::SQL::Any`
  # with `T` the type of the column.
  #
  # * `column_name : String`: If the name of the column in the model doesn't fit the name of the
  #   column in the SQL, you can use the parameter `column_name` to tell Clear about
  #   which db column is linked to current field.
  #
  # * `presence : Bool (default = true)`: Use this option to let know Clear that
  #   your column is not nullable but with default value generated by the database
  #   on insert (e.g. serial)
  # During validation before saving, the presence will not be checked on this field
  #   and Clear will try to insert without the field value.
  #
  macro column(name, primary = false, converter = nil, column_name = nil, presence = true)
    {% _type = name.type %}
    {%
      old_c = _type
      unless converter
        if _type.is_a?(Path)
          if _type.resolve.stringify =~ /\(/
            converter = _type.stringify
          else
            converter = _type.resolve.stringify
          end
        elsif _type.is_a?(Generic) # Union?
          if _type.name.stringify == "::Union"
            converter = (_type.type_vars.map(&.resolve).map(&.stringify).sort.reject { |x| x == "Nil" || x == "::Nil" }.join("")).id.stringify
          else
            converter = _type.resolve.stringify
          end
        elsif _type.is_a?(Union)
          converter = (_type.types.map(&.resolve).map(&.stringify).sort.reject { |x| x == "Nil" || x == "::Nil" }.join("")).id.stringify
        else
          raise "Unknown: #{_type}, #{_type.class}"
        end
      end %}

    {% COLUMNS[name.var] = {
         type:      _type,
         primary:   primary,
         converter: converter,
         column_name: "#{(column_name || name.var)}",
         presence:  presence,
       } %}
  end

  # Used internally to gather the columns
  macro __generate_columns
    {% for name, settings in COLUMNS %}
      {% type = settings[:type] %}
      {% has_db_default = !settings[:presence] %}
      @{{name}}_column : Clear::Model::Column({{type}}) = Clear::Model::Column({{type}}).new("{{name}}",
        has_db_default: {{has_db_default}} )

      def {{name}}_column : Clear::Model::Column({{type}})
        @{{name}}_column
      end

      def {{name}} : {{type}}
        @{{name}}_column.value
      end

      def {{name}}=(x : {{type}})
        @{{name}}_column.value = x
      end

      {% if settings[:primary] %}
        class_property pkey : String = "{{name}}"

        def pkey
          @{{name}}_column.value
        end

        def pkey_column
          @{{name}}_column
        end
      {% end %}
    {% end %}

    def set( t : NamedTuple )
      set(t.to_h)
    end

    # Set the columns from hash
    def set( h : Hash(Symbol, _) )
      super

      {% for name, settings in COLUMNS %}
        v = h.fetch(:{{settings[:column_name]}}){ Column::UNKNOWN }
        @{{name}}_column.reset(Clear::Model::Converter.to_column({{settings[:converter]}}, v)) unless v.is_a?(Column::UnknownClass)
      {% end %}
    end

    # Generate the hash for update request (like during save)
    def update_h : Hash(String, ::Clear::SQL::Any)
      o = super

      {% for name, settings in COLUMNS %}
        if @{{name}}_column.defined? &&
           @{{name}}_column.changed?
          o[{{settings[:column_name]}}] = Clear::Model::Converter.to_db({{settings[:converter]}}, @{{name}}_column.value)
        end
      {% end %}

      o
    end

    # For each column, ensure than when needed the column has present
    # information into it.
    # This method is called on validation.
    def validate_fields_presence
      {% for name, settings in COLUMNS %}
        unless persisted?
          if @{{name}}_column.failed_to_be_present?
            add_error({{name.stringify}}, "must be present")
          end
        end
      {% end %}
    end

    # Reset the `changed?` flag on all columns
    #
    # The model behave like its not dirty anymore
    # and call to save would apply no changes.
    def clear_change_flags
      {% for name, settings in COLUMNS %}
        @{{name}}_column.clear_change_flag
      {% end %}
    end

    # Return a hash version of the columns of this model.
    def to_h : Hash(String, ::Clear::SQL::Any)
      out = super

      {% for name, settings in COLUMNS %}
        if @{{name}}_column.defined?
          out[{{settings[:column_name]}}] = Clear::Model::Converter.to_db({{settings[:converter]}}, @{{name}}_column.value(nil))
        end
      {% end %}

      out
    end

    # Return `true` if the model is dirty (e.g. one or more fields
    #   have been changed.). Return `false` otherwise.
    def changed?
      {% for name, settings in COLUMNS %}
          return true if @{{name}}_column.changed?
      {% end %}

      return false
    end

    # Set the model fields from hash
    def set( h : Hash(String, ::Clear::SQL::Any) )
      super

      {% for name, settings in COLUMNS %}
        if h.has_key?({{settings[:column_name]}})
          @{{name}}_column.reset(Clear::Model::Converter.to_column({{settings[:converter]}}, h[{{settings[:column_name]}}]))
        end
      {% end %}
    end

  end
end
